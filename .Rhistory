exp(lambda * (h_1 - 1)) # ajouter k = 1
}
# output pdf_M
Re(fft(phiM, inverse = T))/nfft
}
# Validation pdf_M ----
alpha12 = 0.2 ; alpha23 = 0.4; alpha24 = 0.7 # dépendances
# Matrice adjacente
A = matrix(c(1, alpha12, 0, 0,
alpha12, 1, alpha23, alpha24,
0, alpha23, 1, 0,
0, alpha24, 0, 1),
nrow = 4,
byrow = TRUE)
lambda = 10 # paramètre des lois de Poisson
fM = pdf_M(A, lambda)
h_k
H
1 - A[pi_k, k] + A[pi_k, k] * h_k
H[pi_k, k]
H[pi_k, k] <-  1 - A[pi_k, k] + A[pi_k, k] * h_k
H
pi_k
pi_k
A
h_k
d
k
H
h_k
H
h_k
pi_k
k
H
expand.grid(0:10, 0:10, 0:10, 0:10)
grid <- expand.grid(0:10, 0:10, 0:10, 0:10)
for (i in 0:20)
{
Mm <- grid[M == i, ]
print(sum(apply(Mm, 1, function(a) pdf_MPMRF(A, lam, a, 1))))
fMM[i + 1]
}
# fonctionne pour le moment; à tester davantage
find_parent_of_v = function(A, v, root_node){
# A : matrice d'adjacence
# v : numéro du child
# root_node : numéro de la racine
g = graph_from_adjacency_matrix(A,
mode = "undirected",
weighted = TRUE,
diag = FALSE)
mst_g = mst(g)
browser()
pav = shortest_paths(mst_g,
from = root_node,
to = v)$vpath[[1]][length(shortest_paths(mst_g,
from = root_node,
to = v)$vpath[[1]]) - 1]
# output pa(v)
as.numeric(pav)
}
for (i in 0:20)
{
Mm <- grid[M == i, ]
print(sum(apply(Mm, 1, function(a) pdf_MPMRF(A, lam, a, 1))))
print(fMM[i + 1])
}
A
v
mst_g
g
graph_from_adjacency_matrix(A,
mode = "undirected",
weighted = TRUE,
diag = FALSE)
mst_g
shortest_paths(mst_g,
from = root_node,
to = v)
v
shortest_paths(mst_g,
from = root_node,
to = v)
pav = shortest_paths(mst_g,
from = root_node,
to = v)$vpath[[1]][length(shortest_paths(mst_g,
from = root_node,
to = v)$vpath[[1]]) - 1]
pav
pdf_MPMRF = function(A, lambda, x_vec, root_node){
# A : matrice d'adjacence
# lambda : paramètre des lois de Poisson
# x_vec : (x_1, ..., x_d)
# root_node : numéro de la racine
d = nrow(A)
v_no_root = seq(d)[-root_node]
prod_vec = numeric(d - 1)
i = 0
for (v in v_no_root){
i = i + 1 # stock prod_vec
# parent de v
#pav = find_parent_of_v(A, v, root_node)
pav = min(which(A[v, ]))
sum_v = 0
for (k in seq(0, min(x_vec[pav], x_vec[v]))){
sum_v = sum_v +
(exp(-lambda * (1 - A[pav, v])) *
(lambda * (1 - A[pav, v]))^(x_vec[v] - k)) /
factorial(x_vec[v] - k) *
choose(x_vec[pav], k) *
A[pav, v]^k *
(1 - A[pav, v])^(x_vec[pav] - k)
## Proposition pour simplifier :
#sum_v = sum_v + dpois(x_vec[v] - k, lambda *  (1 - A[pav, v])) *
#dbinom(k, x_vec[pav], A[pav, v])
}
prod_vec[i] = sum_v
}
# output pdf
dpois(x_vec[root_node], lambda) * prod(prod_vec)
}
pdf_MPMRF = function(A, lambda, x_vec, root_node){
# A : matrice d'adjacence
# lambda : paramètre des lois de Poisson
# x_vec : (x_1, ..., x_d)
# root_node : numéro de la racine
d = nrow(A)
v_no_root = seq(d)[-root_node]
prod_vec = numeric(d - 1)
i = 0
for (v in v_no_root){
i = i + 1 # stock prod_vec
# parent de v
#pav = find_parent_of_v(A, v, root_node)
pav = min(which(A[v, ]))
sum_v = 0
for (k in seq(0, min(x_vec[pav], x_vec[v]))){
sum_v = sum_v +
(exp(-lambda * (1 - A[pav, v])) *
(lambda * (1 - A[pav, v]))^(x_vec[v] - k)) /
factorial(x_vec[v] - k) *
choose(x_vec[pav], k) *
A[pav, v]^k *
(1 - A[pav, v])^(x_vec[pav] - k)
## Proposition pour simplifier :
#sum_v = sum_v + dpois(x_vec[v] - k, lambda *  (1 - A[pav, v])) *
#dbinom(k, x_vec[pav], A[pav, v])
}
prod_vec[i] = sum_v
}
# output pdf
dpois(x_vec[root_node], lambda) * prod(prod_vec)
}
# Validation pdf_MPMRF ----
alpha12 = 0.2 ; alpha23 = 0.4; alpha24 = 0.7 # dépendances
# Matrice adjacente
A = matrix(c(1, alpha12, 0, 0,
alpha12, 1, alpha23, alpha24,
0, alpha23, 1, 0,
0, alpha24, 0, 1),
nrow = 4,
byrow = TRUE)
pdf_MPMRF(A, lam, c(1, 1, 1, 1), 1)
pdf_MPMRF = function(A, lambda, x_vec, root_node){
# A : matrice d'adjacence
# lambda : paramètre des lois de Poisson
# x_vec : (x_1, ..., x_d)
# root_node : numéro de la racine
d = nrow(A)
v_no_root = seq(d)[-root_node]
prod_vec = numeric(d - 1)
i = 0
for (v in v_no_root){
i = i + 1 # stock prod_vec
# parent de v
#pav = find_parent_of_v(A, v, root_node)
pav = min(which(A[v, ] > 0))
sum_v = 0
for (k in seq(0, min(x_vec[pav], x_vec[v]))){
sum_v = sum_v +
(exp(-lambda * (1 - A[pav, v])) *
(lambda * (1 - A[pav, v]))^(x_vec[v] - k)) /
factorial(x_vec[v] - k) *
choose(x_vec[pav], k) *
A[pav, v]^k *
(1 - A[pav, v])^(x_vec[pav] - k)
## Proposition pour simplifier :
#sum_v = sum_v + dpois(x_vec[v] - k, lambda *  (1 - A[pav, v])) *
#dbinom(k, x_vec[pav], A[pav, v])
}
prod_vec[i] = sum_v
}
# output pdf
dpois(x_vec[root_node], lambda) * prod(prod_vec)
}
# Matrice adjacente
A = matrix(c(1, alpha12,
alpha12, 1),
nrow = 2,
byrow = TRUE)
pdf_MPMRF(A, lam, c(0, 1), 1)
dpois(0, lam) * dpois(1, (1 - alpha12) * lam) * dbinom(0, 0, alpha12)
# Validation pdf_MPMRF ----
alpha12 = 0.2 ; alpha23 = 0.4; alpha24 = 0.7 # dépendances
# Matrice adjacente
A = matrix(c(1, alpha12, 0, 0,
alpha12, 1, alpha23, alpha24,
0, alpha23, 1, 0,
0, alpha24, 0, 1),
nrow = 4,
byrow = TRUE)
pdf_MPMRF(A, lam, c(1, 1, 1, 1), 1)
pdf_MPMRF(A, lam, c(0, 0, 0, 0), 1)
pdf_MPMRF = function(A, lambda, x_vec, root_node){
# A : matrice d'adjacence
# lambda : paramètre des lois de Poisson
# x_vec : (x_1, ..., x_d)
# root_node : numéro de la racine
d = nrow(A)
v_no_root = seq(d)[-root_node]
prod_vec = numeric(d - 1)
i = 0
for (v in v_no_root){
i = i + 1 # stock prod_vec
# parent de v
pav = find_parent_of_v(A, v, root_node)
#pav = min(which(A[v, ] > 0))
sum_v = 0
for (k in seq(0, min(x_vec[pav], x_vec[v]))){
sum_v = sum_v +
(exp(-lambda * (1 - A[pav, v])) *
(lambda * (1 - A[pav, v]))^(x_vec[v] - k)) /
factorial(x_vec[v] - k) *
choose(x_vec[pav], k) *
A[pav, v]^k *
(1 - A[pav, v])^(x_vec[pav] - k)
## Proposition pour simplifier :
#sum_v = sum_v + dpois(x_vec[v] - k, lambda *  (1 - A[pav, v])) *
#dbinom(k, x_vec[pav], A[pav, v])
}
prod_vec[i] = sum_v
}
# output pdf
dpois(x_vec[root_node], lambda) * prod(prod_vec)
}
# Validation pdf_MPMRF ----
alpha12 = 0.2 ; alpha23 = 0.4; alpha24 = 0.7 # dépendances
# Matrice adjacente
A = matrix(c(1, alpha12, 0, 0,
alpha12, 1, alpha23, alpha24,
0, alpha23, 1, 0,
0, alpha24, 0, 1),
nrow = 4,
byrow = TRUE)
A
pdf_MPMRF()
fM
for (i in 0:20)
{
m <- i
Mm <- grid[M == m, ]
a <- sum(apply(Mm, 1, function(a) pdf_MPMRF(A, lam, a, 1))); b <- fM[m+1]
print(c(a, b))
}
# fonctionne pour le moment; à tester davantage
find_parent_of_v = function(A, v, root_node){
# A : matrice d'adjacence
# v : numéro du child
# root_node : numéro de la racine
g = graph_from_adjacency_matrix(A,
mode = "undirected",
weighted = TRUE,
diag = FALSE)
mst_g = mst(g)
pav = shortest_paths(mst_g,
from = root_node,
to = v)$vpath[[1]][length(shortest_paths(mst_g,
from = root_node,
to = v)$vpath[[1]]) - 1]
# output pa(v)
as.numeric(pav)
}
for (i in 0:20)
{
m <- i
Mm <- grid[M == m, ]
a <- sum(apply(Mm, 1, function(a) pdf_MPMRF(A, lam, a, 1))); b <- fM[m+1]
print(c(a, b))
}
for (i in 0:20)
{
m <- i
Mm <- grid[M == m, ]
a <- sum(apply(Mm, 1, function(a) pdf_MPMRF(A, lam, a, 1))); b <- fM[m+1]
print(c(a, b))
}
pdf_MPMRF = function(A, lambda, x_vec, root_node){
# A : matrice d'adjacence
# lambda : paramètre des lois de Poisson
# x_vec : (x_1, ..., x_d)
# root_node : numéro de la racine
d = nrow(A)
v_no_root = seq(d)[-root_node]
prod_vec = numeric(d - 1)
i = 0
for (v in v_no_root){
i = i + 1 # stock prod_vec
# parent de v
pav = find_parent_of_v(A, v, root_node)
#pav = min(which(A[v, ] > 0))
sum_v = 0
browser()
for (k in seq(0, min(x_vec[pav], x_vec[v]))){
sum_v = sum_v +
(exp(-lambda * (1 - A[pav, v])) *
(lambda * (1 - A[pav, v]))^(x_vec[v] - k)) /
factorial(x_vec[v] - k) *
choose(x_vec[pav], k) *
A[pav, v]^k *
(1 - A[pav, v])^(x_vec[pav] - k)
## Proposition pour simplifier :
#sum_v = sum_v + dpois(x_vec[v] - k, lambda *  (1 - A[pav, v])) *
#dbinom(k, x_vec[pav], A[pav, v])
}
prod_vec[i] = sum_v
}
# output pdf
dpois(x_vec[root_node], lambda) * prod(prod_vec)
}
for (i in 0:20)
{
m <- i
Mm <- grid[M == m, ]
a <- sum(apply(Mm, 1, function(a) pdf_MPMRF(A, lam, a, 1))); b <- fM[m+1]
print(c(a, b))
}
min(x_vec[pav], x_vec[v])
min(x_vec[pav], x_vec[v])
pdf_MPMRF = function(A, lambda, x_vec, root_node){
# A : matrice d'adjacence
# lambda : paramètre des lois de Poisson
# x_vec : (x_1, ..., x_d)
# root_node : numéro de la racine
d = nrow(A)
v_no_root = seq(d)[-root_node]
prod_vec = numeric(d - 1)
i = 0
for (v in v_no_root){
i = i + 1 # stock prod_vec
# parent de v
pav = find_parent_of_v(A, v, root_node)
#pav = min(which(A[v, ] > 0))
sum_v = 0
print(pav)
for (k in seq(0, min(x_vec[pav], x_vec[v]))){
sum_v = sum_v +
(exp(-lambda * (1 - A[pav, v])) *
(lambda * (1 - A[pav, v]))^(x_vec[v] - k)) /
factorial(x_vec[v] - k) *
choose(x_vec[pav], k) *
A[pav, v]^k *
(1 - A[pav, v])^(x_vec[pav] - k)
## Proposition pour simplifier :
#sum_v = sum_v + dpois(x_vec[v] - k, lambda *  (1 - A[pav, v])) *
#dbinom(k, x_vec[pav], A[pav, v])
}
prod_vec[i] = sum_v
}
# output pdf
dpois(x_vec[root_node], lambda) * prod(prod_vec)
}
for (i in 0:20)
{
m <- i
Mm <- grid[M == m, ]
a <- sum(apply(Mm, 1, function(a) pdf_MPMRF(A, lam, a, 1))); b <- fM[m+1]
print(c(a, b))
}
pdf_MPMRF = function(A, lambda, x_vec, root_node){
# A : matrice d'adjacence
# lambda : paramètre des lois de Poisson
# x_vec : (x_1, ..., x_d)
# root_node : numéro de la racine
d = nrow(A)
v_no_root = seq(d)[-root_node]
prod_vec = numeric(d - 1)
i = 0
for (v in v_no_root){
i = i + 1 # stock prod_vec
# parent de v
pav = find_parent_of_v(A, v, root_node)
#pav = min(which(A[v, ] > 0))
sum_v = 0
print(pav); print(v); print(x_vec)
for (k in seq(0, min(x_vec[pav], x_vec[v]))){
sum_v = sum_v +
(exp(-lambda * (1 - A[pav, v])) *
(lambda * (1 - A[pav, v]))^(x_vec[v] - k)) /
factorial(x_vec[v] - k) *
choose(x_vec[pav], k) *
A[pav, v]^k *
(1 - A[pav, v])^(x_vec[pav] - k)
## Proposition pour simplifier :
#sum_v = sum_v + dpois(x_vec[v] - k, lambda *  (1 - A[pav, v])) *
#dbinom(k, x_vec[pav], A[pav, v])
}
prod_vec[i] = sum_v
}
# output pdf
dpois(x_vec[root_node], lambda) * prod(prod_vec)
}
for (i in 0:20)
{
m <- i
Mm <- grid[M == m, ]
a <- sum(apply(Mm, 1, function(a) pdf_MPMRF(A, lam, a, 1))); b <- fM[m+1]
print(c(a, b))
}
Mm
apply(Mm, 1, function(a) sum(is.na(a)))
grid[M == m, ]
Mm <- grid[M == m, ]
View(Mm)
grid <- expand.grid(0:20, 0:20, 0:20)
M <- rowSums(grid)
summary(M)
grid <- expand.grid(0:20, 0:20, 0:20, 0:20)
M <- rowSums(grid)
for (i in 0:20)
{
m <- i
Mm <- grid[M == m, ]
a <- sum(apply(Mm, 1, function(a) pdf_MPMRF(A, lam, a, 1))); b <- fM[m+1]
print(c(a, b))
}
pdf_M = function(A, lambda){
# A : matrice d'adjacence
# lambda : paramètre des lois de Poisson
d = nrow(A)
nfft = 2^15
b = c(0, 1, rep(0, nfft - 2)) # fmp v.a. dégénérée à 1
phib = fft(b)
phiM = numeric(nfft)
stock_pi_k = numeric(d - 1)
stock_h_k = numeric(d - 1)
k_domain = rev(seq(d)[-1])
browser()
for (l in seq(nfft)){
H = matrix(data = 1,
nrow = d,
ncol = d) # all-1 matrix
for (k in k_domain){
pi_k = min(which(A[k,] > 0)) # infimum (devrait jamais donner infini parce
# que sinon ça veut dire qu'il y a un node indépendant de tous les autres)
h_k = phib[l] * prod(H[k,])
H[pi_k, k] <-  1 - A[pi_k, k] + A[pi_k, k] * h_k # overwrite H
stock_pi_k[k - 1] = pi_k
stock_h_k[k - 1] = h_k
}
h_1 = phib[l] * prod(H[1,])
prod_vec = numeric(length(k_domain))
for (k in k_domain){
prod_vec[k - 1] = exp(lambda * (1 - A[stock_pi_k[k - 1], k]) *
(stock_h_k[k - 1] - 1))
}
phiM[l] = prod(prod_vec) *
exp(lambda * (h_1 - 1)) # ajouter k = 1
}
# output pdf_M
Re(fft(phiM, inverse = T))/nfft
}
# Validation pdf_M ----
alpha12 = 0.2 ; alpha23 = 0.4; alpha24 = 0.7 # dépendances
# Matrice adjacente
A = matrix(c(1, alpha12, 0, 0,
alpha12, 1, alpha23, alpha24,
0, alpha23, 1, 0,
0, alpha24, 0, 1),
nrow = 4,
byrow = TRUE)
lambda = 10 # paramètre des lois de Poisson
fM = pdf_M(A, lambda)
k_domain
k_domain
sotck_phi_k
stock_phi_k
stock_pi_k
pi_k
h_k
pi_k
H[pi_k, k]
stock_pi_k
stock_pi_k
stock_h_k
stock_h_k
stock_pi_k
H
stock_pi_k
stock_h_k
A
h_1
h_k
k
k_domain
A
k - 1
lambda
1 - A[stock_pi_k[k - 1], k]
stock_pi_k[k - 1]
pi_k
ffb
